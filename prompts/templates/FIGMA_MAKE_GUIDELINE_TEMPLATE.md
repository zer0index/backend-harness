# Backend Integration Guidelines for Frontend Development

> **Purpose:** Universal guidelines for building React/TypeScript frontends that integrate with FastAPI backends generated by our autonomous backend tool.
>
> **Copy this file to:** `guidelines/guideline.md` in your Figma Make project

---

## ‚ö†Ô∏è CRITICAL: Development Environment Constraints

### Figma Make Cloud Environment Limitations

**IMPORTANT:** Figma Make runs in a cloud-hosted environment and **CANNOT** access:

- ‚ùå `http://localhost:8000` or any localhost ports
- ‚ùå `http://127.0.0.1:*` or loopback addresses
- ‚ùå Local development servers on your machine
- ‚ùå Private networks or VPNs
- ‚ùå Services running on your computer

### The Solution: Mock Data Development

**During ALL development in Figma Make:**
- ‚úÖ Use mock data from `mock-data/*.json` files
- ‚úÖ Import JSON files directly into components
- ‚úÖ Build and test complete UI with realistic data
- ‚úÖ Structure code for easy API swapping later

**After downloading the generated code:**
- ‚úÖ Run locally on your machine
- ‚úÖ Swap mock data imports for real API calls
- ‚úÖ Connect to local backend (`http://localhost:8000`)
- ‚úÖ Test full integration

---

## 1. Mock Data Development Pattern

### In Figma Make (Cloud Environment)

**Always use static imports from JSON files:**

```typescript
// ‚úÖ CORRECT - Direct JSON import (works in Figma Make)
import users from './mock-data/users.json';
import tasks from './mock-data/tasks.json';
import comments from './mock-data/comments.json';

const UserList = () => {
  const [users, setUsers] = useState<User[]>(mockUsers);

  // Simulate async loading for realism
  useEffect(() => {
    setLoading(true);
    setTimeout(() => {
      setUsers(mockUsers);
      setLoading(false);
    }, 500);
  }, []);

  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};
```

```typescript
// ‚ùå WRONG - Trying to fetch from localhost (will fail in Figma Make)
const UserList = () => {
  useEffect(() => {
    fetch('http://localhost:8000/api/v1/users')  // ‚ùå Will not work!
      .then(r => r.json())
      .then(setUsers);
  }, []);
};
```

### After Download (Local Environment)

**Create an API abstraction layer for easy swapping:**

```typescript
// api/config.ts
export const USE_MOCK_DATA = false; // Toggle this after download

// api/users.ts
import { USE_MOCK_DATA } from './config';
import mockUsers from '../mock-data/users.json';

export const getUsers = async (): Promise<User[]> => {
  if (USE_MOCK_DATA) {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 300));
    return mockUsers;
  }

  const response = await fetch('http://localhost:8000/api/v1/users');
  if (!response.ok) throw new Error('Failed to fetch users');
  return response.json();
};

export const createUser = async (userData: CreateUserInput): Promise<User> => {
  if (USE_MOCK_DATA) {
    // Return mock created user
    return { id: Date.now(), ...userData, created_at: new Date().toISOString() };
  }

  const response = await fetch('http://localhost:8000/api/v1/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(userData),
  });
  if (!response.ok) throw new Error('Failed to create user');
  return response.json();
};

// Components use this abstraction
const UserList = () => {
  const { data: users, isLoading, error } = useQuery('users', getUsers);
  // Works with mock data OR real API - no component changes needed!
};
```

### Best Practice: Single Source of Truth

```typescript
// lib/api.ts - Central API abstraction
const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';
const USE_MOCK = import.meta.env.VITE_USE_MOCK_DATA === 'true';

class ApiClient {
  async get<T>(endpoint: string, mockData?: T): Promise<T> {
    if (USE_MOCK && mockData) {
      await this.simulateDelay();
      return mockData;
    }
    return this.fetchJSON(`${API_BASE_URL}${endpoint}`);
  }

  async post<T>(endpoint: string, data: any, mockResponse?: T): Promise<T> {
    if (USE_MOCK && mockResponse) {
      await this.simulateDelay();
      return mockResponse;
    }
    return this.fetchJSON(`${API_BASE_URL}${endpoint}`, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  private async simulateDelay() {
    await new Promise(resolve => setTimeout(resolve, 300));
  }

  private async fetchJSON(url: string, options?: RequestInit) {
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
    });
    if (!response.ok) throw new Error(`API error: ${response.status}`);
    return response.json();
  }
}

export const api = new ApiClient();

// Usage in hooks
export const useUsers = () => {
  return useQuery('users', () => api.get('/api/v1/users', mockUsers));
};
```

---

## 2. Data Model Adherence (NON-NEGOTIABLE)

### The Golden Rule

**The backend is complete and deployed. Frontend MUST match backend schemas exactly.**

### Critical Requirements

**‚úÖ DO:**
- Use EXACT field names from `FRONTEND_HANDOFF.md` TypeScript interfaces
- Match ALL data types precisely (string, number, boolean, Date, etc.)
- Respect enum values exactly as defined
- Handle all optional fields (field?: type)
- Use snake_case for field names (backend convention)

**‚ùå NEVER:**
- Change field names (e.g., `user_id` ‚Üí `userId`)
- Add fields that don't exist in backend
- Modify data types (e.g., `string` ‚Üí `Date` object)
- Change enum values or add new ones
- Ignore optional fields

### Example: Correct vs. Incorrect

**From FRONTEND_HANDOFF.md:**
```typescript
interface Task {
  id: number;
  title: string;
  description?: string;
  status: "todo" | "in_progress" | "done";
  priority: "low" | "medium" | "high";
  user_id: number;
  created_at: string;
  updated_at: string;
  due_date?: string;
}
```

**‚úÖ CORRECT Usage:**
```typescript
import { Task } from './types'; // From FRONTEND_HANDOFF.md

const TaskCard = ({ task }: { task: Task }) => {
  // Use exact field names
  const statusColor = task.status === 'done' ? 'green' : 'blue';

  // Handle optional fields
  const description = task.description || 'No description';

  // Use enum values exactly
  const isHighPriority = task.priority === 'high';

  return (
    <div>
      <h3>{task.title}</h3>
      <p>{description}</p>
      <Badge color={statusColor}>{task.status}</Badge>
      <span>Assigned to user: {task.user_id}</span>
    </div>
  );
};
```

**‚ùå WRONG Usage:**
```typescript
// ‚ùå Changed field names to camelCase
interface Task {
  id: number;
  title: string;
  userId: number;        // ‚ùå Should be user_id
  createdAt: Date;       // ‚ùå Should be string (ISO format)
  status: string;        // ‚ùå Lost type safety (should be enum)
}

// ‚ùå Added field not in backend
interface Task {
  id: number;
  title: string;
  assignedUserName: string;  // ‚ùå Not in backend schema
}
```

### Validation Strategy

**Before using any interface:**
1. Open `FRONTEND_HANDOFF.md`
2. Copy the TypeScript interface EXACTLY
3. Do not modify field names, types, or enums
4. Add JSDoc comments if needed for clarity

**Runtime validation (recommended):**
```typescript
import { z } from 'zod';

// Define schema matching backend exactly
const TaskSchema = z.object({
  id: z.number(),
  title: z.string(),
  description: z.string().optional(),
  status: z.enum(['todo', 'in_progress', 'done']),
  priority: z.enum(['low', 'medium', 'high']),
  user_id: z.number(),
  created_at: z.string(),
  updated_at: z.string(),
  due_date: z.string().optional(),
});

// Validate API responses
const response = await fetch('/api/v1/tasks/1');
const data = await response.json();
const task = TaskSchema.parse(data); // Throws if mismatch
```

---

## 3. TypeScript Best Practices

### Import Types from FRONTEND_HANDOFF.md

**Create a central types file:**
```typescript
// types/index.ts
// Copy ALL interfaces from FRONTEND_HANDOFF.md exactly as provided

export interface User {
  id: number;
  email: string;
  display_name: string;
  created_at: string;
  is_active: boolean;
}

export interface Task {
  id: number;
  title: string;
  status: "todo" | "in_progress" | "done";
  user_id: number;
  created_at: string;
}

// ... all other interfaces
```

### Use Strict TypeScript

**tsconfig.json:**
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noUncheckedIndexedAccess": true
  }
}
```

### Define Props Interfaces

```typescript
// ‚úÖ Good - Explicit props interface
interface TaskCardProps {
  task: Task;
  onEdit?: (task: Task) => void;
  onDelete?: (id: number) => void;
  showActions?: boolean;
}

const TaskCard = ({ task, onEdit, onDelete, showActions = true }: TaskCardProps) => {
  // Type-safe component
};
```

### Avoid 'any' Type

```typescript
// ‚ùå Bad
const handleSubmit = (data: any) => {
  console.log(data.title); // No type safety
};

// ‚úÖ Good
const handleSubmit = (data: CreateTaskInput) => {
  console.log(data.title); // Type-safe
};
```

---

## 4. API Error Handling

### Standard Error Response Pattern

**Most backends return errors in this format:**
```typescript
interface ApiError {
  detail: string;
  status_code?: number;
}
```

### Error Handling Pattern

```typescript
const handleApiError = (error: any): string => {
  if (error.response?.data?.detail) {
    return error.response.data.detail;
  }
  if (error.message) {
    return error.message;
  }
  return 'An unexpected error occurred';
};

// Usage in component
const createTask = async (taskData: CreateTaskInput) => {
  try {
    setLoading(true);
    setError(null);
    const task = await api.post('/api/v1/tasks', taskData);
    toast.success('Task created successfully');
    return task;
  } catch (err) {
    const errorMessage = handleApiError(err);
    setError(errorMessage);
    toast.error(errorMessage);
  } finally {
    setLoading(false);
  }
};
```

### Common HTTP Status Codes

| Code | Meaning | Action |
|------|---------|--------|
| 200 | Success | Show success message |
| 201 | Created | Show success, redirect to new resource |
| 400 | Bad Request | Show validation errors |
| 401 | Unauthorized | Redirect to login |
| 403 | Forbidden | Show permission error |
| 404 | Not Found | Show "not found" message |
| 409 | Conflict | Show conflict error (e.g., duplicate) |
| 422 | Validation Error | Show field-level errors |
| 500 | Server Error | Show generic error, log to monitoring |

---

## 5. Loading & Empty States

### Loading States

**Always show loading indicators during async operations:**

```typescript
const TaskList = () => {
  const { data: tasks, isLoading, error } = useQuery('tasks', getTasks);

  if (isLoading) {
    return <Skeleton count={5} height={80} />;
    // Or: return <Spinner />;
  }

  if (error) {
    return <ErrorMessage error={error} />;
  }

  return (
    <div>
      {tasks.map(task => <TaskCard key={task.id} task={task} />)}
    </div>
  );
};
```

### Empty States

**Design meaningful empty states:**

```typescript
const TaskList = () => {
  const { data: tasks } = useQuery('tasks', getTasks);

  if (!tasks || tasks.length === 0) {
    return (
      <EmptyState
        icon={<TaskIcon />}
        title="No tasks yet"
        description="Create your first task to get started"
        action={
          <Button onClick={() => navigate('/tasks/new')}>
            Create Task
          </Button>
        }
      />
    );
  }

  return <div>{/* Task list */}</div>;
};
```

### Optimistic Updates

**For better UX, update UI before API responds:**

```typescript
const useUpdateTask = () => {
  const queryClient = useQueryClient();

  return useMutation(
    (updatedTask: Task) => api.put(`/api/v1/tasks/${updatedTask.id}`, updatedTask),
    {
      // Optimistically update cache
      onMutate: async (updatedTask) => {
        await queryClient.cancelQueries(['tasks']);

        const previousTasks = queryClient.getQueryData<Task[]>(['tasks']);

        queryClient.setQueryData<Task[]>(['tasks'], (old = []) =>
          old.map(task => task.id === updatedTask.id ? updatedTask : task)
        );

        return { previousTasks };
      },
      // Rollback on error
      onError: (err, updatedTask, context) => {
        queryClient.setQueryData(['tasks'], context?.previousTasks);
      },
      // Refetch on success
      onSettled: () => {
        queryClient.invalidateQueries(['tasks']);
      },
    }
  );
};
```

---

## 6. Testing Strategy

### Component Testing

**Use Vitest + Testing Library:**

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { TaskCard } from './TaskCard';

describe('TaskCard', () => {
  const mockTask: Task = {
    id: 1,
    title: 'Test Task',
    status: 'todo',
    user_id: 1,
    created_at: '2024-01-01T00:00:00Z',
    updated_at: '2024-01-01T00:00:00Z',
  };

  it('renders task title', () => {
    render(<TaskCard task={mockTask} />);
    expect(screen.getByText('Test Task')).toBeInTheDocument();
  });

  it('calls onEdit when edit button clicked', () => {
    const onEdit = vi.fn();
    render(<TaskCard task={mockTask} onEdit={onEdit} />);

    fireEvent.click(screen.getByRole('button', { name: /edit/i }));
    expect(onEdit).toHaveBeenCalledWith(mockTask);
  });
});
```

### Mock API Calls

```typescript
import { rest } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
  rest.get('/api/v1/tasks', (req, res, ctx) => {
    return res(ctx.json(mockTasks));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

---

## 7. Performance Best Practices

### Code Splitting

```typescript
// Lazy load heavy components
const Dashboard = lazy(() => import('./pages/Dashboard'));
const TaskDetail = lazy(() => import('./pages/TaskDetail'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/" element={<Dashboard />} />
        <Route path="/tasks/:id" element={<TaskDetail />} />
      </Routes>
    </Suspense>
  );
}
```

### React Query Caching

```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      refetchOnWindowFocus: false,
    },
  },
});
```

### Debounce Search Inputs

```typescript
import { useDebouncedValue } from '@mantine/hooks';

const SearchBar = () => {
  const [search, setSearch] = useState('');
  const [debounced] = useDebouncedValue(search, 300);

  const { data } = useQuery(['search', debounced], () =>
    api.get(`/api/v1/tasks?search=${debounced}`)
  );
};
```

---

## 8. Accessibility Requirements

### Minimum WCAG AA Compliance

**Semantic HTML:**
```typescript
// ‚úÖ Good
<button onClick={handleClick}>Submit</button>
<nav><a href="/tasks">Tasks</a></nav>

// ‚ùå Bad
<div onClick={handleClick}>Submit</div>
<div><span onClick={() => navigate('/tasks')}>Tasks</span></div>
```

**ARIA Labels:**
```typescript
<button aria-label="Delete task" onClick={onDelete}>
  <TrashIcon />
</button>

<input
  type="text"
  aria-label="Search tasks"
  aria-describedby="search-help"
/>
<span id="search-help">Enter keywords to search tasks</span>
```

**Keyboard Navigation:**
```typescript
const handleKeyDown = (e: KeyboardEvent) => {
  if (e.key === 'Enter' || e.key === ' ') {
    handleAction();
  }
};

<div
  role="button"
  tabIndex={0}
  onKeyDown={handleKeyDown}
  onClick={handleAction}
>
  Interactive Element
</div>
```

**Focus Management:**
```typescript
const modalRef = useRef<HTMLDivElement>(null);

useEffect(() => {
  if (isOpen) {
    modalRef.current?.focus();
  }
}, [isOpen]);

<div ref={modalRef} tabIndex={-1} role="dialog">
  {/* Modal content */}
</div>
```

---

## 9. Code Organization

### Recommended File Structure

```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/              # Reusable UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Card.tsx
‚îÇ   ‚îú‚îÄ‚îÄ tasks/           # Domain-specific components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskCard.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskList.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaskForm.tsx
‚îÇ   ‚îî‚îÄ‚îÄ layout/          # Layout components
‚îÇ       ‚îú‚îÄ‚îÄ Header.tsx
‚îÇ       ‚îú‚îÄ‚îÄ Sidebar.tsx
‚îÇ       ‚îî‚îÄ‚îÄ Layout.tsx
‚îú‚îÄ‚îÄ pages/               # Route components
‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.tsx
‚îÇ   ‚îú‚îÄ‚îÄ TasksPage.tsx
‚îÇ   ‚îî‚îÄ‚îÄ TaskDetailPage.tsx
‚îú‚îÄ‚îÄ hooks/               # Custom hooks
‚îÇ   ‚îú‚îÄ‚îÄ useTasks.ts
‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îî‚îÄ‚îÄ useForm.ts
‚îú‚îÄ‚îÄ lib/                 # Utilities and config
‚îÇ   ‚îú‚îÄ‚îÄ api.ts
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts
‚îÇ   ‚îî‚îÄ‚îÄ constants.ts
‚îú‚îÄ‚îÄ types/               # TypeScript types (from FRONTEND_HANDOFF.md)
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ mock-data/           # JSON mock data files
‚îÇ   ‚îú‚îÄ‚îÄ users.json
‚îÇ   ‚îî‚îÄ‚îÄ tasks.json
‚îî‚îÄ‚îÄ App.tsx
```

### Component Organization

**One component per file:**
```typescript
// TaskCard.tsx
interface TaskCardProps {
  task: Task;
  onEdit?: (task: Task) => void;
}

export const TaskCard = ({ task, onEdit }: TaskCardProps) => {
  // Component logic
  return (/* JSX */);
};
```

**Extract helper functions:**
```typescript
// utils/taskUtils.ts
export const getStatusColor = (status: Task['status']) => {
  const colors = {
    todo: 'gray',
    in_progress: 'blue',
    done: 'green',
  };
  return colors[status];
};

export const formatTaskDate = (dateString: string) => {
  return new Date(dateString).toLocaleDateString();
};
```

---

## 10. Quality Checklist

Before marking any feature as complete, ensure:

### TypeScript & Data Models
- [ ] Using exact TypeScript interfaces from `FRONTEND_HANDOFF.md`
- [ ] All field names match backend exactly (snake_case)
- [ ] All enum values match backend exactly
- [ ] Optional fields handled properly
- [ ] No TypeScript errors or warnings
- [ ] No use of `any` type

### Mock Data Integration
- [ ] Using mock data from `mock-data/*.json` files
- [ ] NOT attempting to fetch from localhost
- [ ] Code structured for easy API swapping
- [ ] Mock data imports working in Figma Make

### Error Handling
- [ ] Try-catch blocks around all async operations
- [ ] User-friendly error messages displayed
- [ ] Network errors handled gracefully
- [ ] 404/500 errors handled appropriately

### Loading States
- [ ] Loading indicators during async operations
- [ ] Skeleton loaders or spinners implemented
- [ ] Optimistic updates where appropriate
- [ ] Empty states designed

### Responsive Design
- [ ] Mobile-first approach
- [ ] Tested on mobile, tablet, desktop breakpoints
- [ ] Touch-friendly interactive elements
- [ ] Proper viewport meta tag

### Accessibility
- [ ] Semantic HTML used
- [ ] ARIA labels for icons and actions
- [ ] Keyboard navigation works
- [ ] Focus states visible
- [ ] Color contrast meets WCAG AA

### Code Quality
- [ ] Components are small and focused
- [ ] No duplicate code
- [ ] Clear variable and function names
- [ ] Comments for complex logic
- [ ] No console.log or debugging code

### Testing (After Download)
- [ ] Unit tests for complex logic
- [ ] Component tests for critical features
- [ ] Integration tests for API flows
- [ ] Manual testing of all features

---

## 11. Common Pitfalls to Avoid

### ‚ùå DON'T: Try to Access Local Backend from Figma Make
```typescript
// This will FAIL in Figma Make cloud environment
fetch('http://localhost:8000/api/v1/users')
```

### ‚úÖ DO: Use Mock Data
```typescript
import users from './mock-data/users.json';
```

---

### ‚ùå DON'T: Change Field Names
```typescript
// Backend uses snake_case
interface Task {
  userId: number;  // ‚ùå Wrong
}
```

### ‚úÖ DO: Match Backend Exactly
```typescript
interface Task {
  user_id: number;  // ‚úÖ Correct
}
```

---

### ‚ùå DON'T: Add Fields Not in Backend
```typescript
interface Task {
  id: number;
  title: string;
  assignedUserName: string;  // ‚ùå Not in backend
}
```

### ‚úÖ DO: Use Backend Fields Only
```typescript
interface Task {
  id: number;
  title: string;
  user_id: number;  // ‚úÖ Use ID, fetch user separately if needed
}
```

---

### ‚ùå DON'T: Modify Enum Values
```typescript
// Backend: "todo" | "in_progress" | "done"
type Status = "pending" | "active" | "completed";  // ‚ùå Wrong
```

### ‚úÖ DO: Use Exact Enum Values
```typescript
type Status = "todo" | "in_progress" | "done";  // ‚úÖ Correct
```

---

## 12. Final Reminders

1. **Mock Data First**: Always develop with mock data in Figma Make
2. **No Local API**: Never try to access localhost from Figma Make
3. **Exact Schemas**: Match backend TypeScript interfaces exactly
4. **Easy Swapping**: Structure code for simple mock ‚Üí API transition
5. **Type Safety**: Use strict TypeScript throughout
6. **Error Handling**: Handle all error cases gracefully
7. **Loading States**: Always show loading indicators
8. **Accessibility**: Follow WCAG AA guidelines
9. **Test Thoroughly**: Test with mock data before swapping to API

---

**Questions or Issues?** Review `FRONTEND_HANDOFF.md` for project-specific details and TypeScript interfaces.

**Ready to build!** üöÄ
